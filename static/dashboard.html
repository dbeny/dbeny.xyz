<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Marci Hajonéz Freak-poster</title>
        <link rel="stylesheet" href="/styles/dashboard.css">
        <meta name="theme-color" content="#309ffa">
		<meta name="description"
			content="Mert itt a vég tudománya (tényleg) amit még törött szemhéjjal se nyunyálsz. Végső nyugovóra tér a hasznos orrú nyugágy, amickor a lenyélő bandó remeg. A itt találod a forgókeverék hasznosságának funkcióját és. Veszíthetetlen pitélytárház és kollektív kacagó.">
		<meta name="image" content="https://github.com/dbeny/dbeny.xyz/blob/main/torjonel.png">
		<meta property="og:image" content="https://github.com/dbeny/dbeny.xyz/blob/main/torjonel.png">
        <link rel="stylesheet"
			href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=open_in_new" />
		<link rel="shortcut icon"
			href="https://cdn.discordapp.com/attachments/899955220468097065/1374635704922935356/picy.png?ex=682ec4c3&is=682d7343&hm=e91fe9a6ff250a3bbb8021f94c715a37138e4d12b72e6ae5b9b861758eb8c6f6&"
			type="image/png">
		<link rel="icon"
			href="https://cdn.discordapp.com/attachments/899955220468097065/1374635704922935356/picy.png?ex=682ec4c3&is=682d7343&hm=e91fe9a6ff250a3bbb8021f94c715a37138e4d12b72e6ae5b9b861758eb8c6f6&"
			type="image/png">
    </head>
    <body>
		<div class="main">
			<div class="content">
				<div class="post_manager">
					<div class="add_post">
						<div class="content_before">
							<span>Text: </span><textarea id="text1"></textarea>
							<span>Reply? </span><input type="checkbox" id="reply1">
						</div>
						<div class="content_after">
							<span>Text: </span><textarea id="text2"></textarea>
							<span>Reply? </span><input type="checkbox" id="reply2">
						</div>
						<div class="image">
							<span>URL: </span><input type="text" id="imgUrl">
							<span>Preview</span><br>
							<img id="preview" src="" alt="kep" class="hidden">
						</div>
						<button id="addPost">Add Post</button>
					</div>
					<div class="edit_post">

					</div>

                    <div class="preview-area">
                        <strong>Preview: </strong>
                        <ul id="postPreview"></ul>
                    </div>
				</div>
				<div class="main_content" id="messageBoard">
					<div class="messages" id="messages"></div>
					<div class="send_message">
						<textarea id="messageInput" placeholder="Write a message..."></textarea>
						<button id="sendBtn">Send</button>
					</div>
				</div>
			</div>
			<footer>
				<div class="links"><a href="/">Home</a></div>
			</footer>
		</div>
    </body>
	<script>
		const board = document.getElementById("messages");
		const input = document.getElementById("messageInput");
		const sendBtn = document.getElementById("sendBtn");

        
        function isValidUrl(str) {
            try {
                new URL(String(str).trim());
                return true;
            } catch (e) {
                return false;
            }
        }

        async function isImageUrl(url) {
            if (!url) return false;
            const s = String(url).trim();
            if (s.startsWith('data:image/')) return true;
            if (/\.(png|jpe?g|gif|bmp|webp|svg)(\?.*)?$/i.test(s)) return true;
            try {
                const res = await fetch(s, { method: 'HEAD' });
                if (!res.ok) return false;
                const ct = res.headers.get('content-type') || '';
                return ct.toLowerCase().startsWith('image/');
            } catch (e) {
                return false;
            }
        }


        async function fetchMessages() {
            console.log("fetching messages");
            const res = await fetch("/messages/fetch");
            const data = await res.json();
            console.log("fetched data: ", JSON.stringify(data, null, 4));
            
            if (!data.success) {
                alert("Failed to fetch messages");
                return;
            }

            board.innerHTML = "";
            for (const m of data.messages) {
                const div = document.createElement("div");
                div.className = "message";

                const strong = document.createElement("strong");
                strong.textContent = m.sender ?? 'unknown';
                
				const time = document.createElement("span");
				const d = new Date(m.date ?? Date.now());

				const pad = n => String(n).padStart(2, "0");
				const formatted = `${d.getFullYear()}.${pad(d.getMonth() + 1)}.${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;

				time.textContent = ` ${formatted}`;
                
                const p = document.createElement("p");
				p.style.whiteSpace = "pre-wrap";
                const content = String(m.content ?? '').trim();

                if (isValidUrl(content)) {
                    const imageCheck = await isImageUrl(content);
                    if (imageCheck) {
                        const img = document.createElement("img");
                        img.src = content;
                        img.alt = "";
                        img.style.maxHeight = "300px";
                        img.style.maxWidth = "100%";
                        img.loading = "lazy";
                        p.appendChild(img);
                    } else {
                        const a = document.createElement("a");
                        a.href = content;
                        a.textContent = content;
                        a.target = "_blank";
                        a.rel = "noopener noreferrer";
                        p.appendChild(a);
                    }
                } else {
                    p.textContent = content;
                }

                div.appendChild(strong);
                div.appendChild(time);
                div.appendChild(p);
                board.appendChild(div);
            }

            board.scrollTop = board.scrollHeight;
        }

		async function sendMessage() {
			const content = input.value.trim();
			if (!content) return;
			let res = await fetch("/messages/add", {
                method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({ content })
			});
			console.log(`send fetch result: ${JSON.stringify(res)}`)
			input.value = "";
			await fetchMessages();
		}
        
		sendBtn.addEventListener("click", sendMessage);

        input.addEventListener('keydown', (e) => {
			if (e.key !== 'Enter') return;
			if (e.isComposing) return;

			// Ctrl/Cmd+Enter -> insert newline
			if (e.ctrlKey || e.shiftKey) {
				const start = input.selectionStart;
				const end = input.selectionEnd;
				const v = input.value;
				input.value = v.slice(0, start) + '\n' + v.slice(end);
				input.selectionStart = input.selectionEnd = start + 1;
				e.preventDefault();
				e.stopImmediatePropagation();
				return;
			}

			// plain Enter -> send
			e.preventDefault();
			e.stopImmediatePropagation();
			sendMessage();
		});
        
		// load messages on page load
		fetchMessages();
		setInterval(() => fetchMessages(), 10*1000);
	</script>
	<script>
		let state = {
			content_before: {
				text: "",
				is_reply: false,
				emote: ""
			},
			content_after: {
				text: "",
				is_reply: false,
				emote: ""
			},
			image: ""
		};

		let text1El = document.getElementById("text1");
		let reply1El = document.getElementById("reply1");
		let text2El = document.getElementById("text2");
		let reply2El = document.getElementById("reply2");
		let imgUrlEl = document.getElementById("imgUrl");
		let previewEl = document.getElementById("preview");

		text1El.addEventListener("input", e => {
			state.content_before.text = e.target.value;
            renderPreview();
		});
		reply1El.addEventListener("change", e => {
			state.content_before.is_reply = e.target.checked;
            renderPreview();
		});
		text2El.addEventListener("input", e => {
			state.content_after.text = e.target.value;
            renderPreview();
            console.log(state)
		});
		reply2El.addEventListener("change", e => {
			state.content_after.is_reply = e.target.checked;
            renderPreview();
		});
		imgUrlEl.addEventListener("input", e => {
			state.image = e.target.value;
            renderPreview();
		});

		async function addPost() {
			let res = await fetch("/posts/add", {
				method: "POST",
				headers: {
					"Content-Type": "application/json"
				},
				body: JSON.stringify(state)
			});
			let json = await res.json();
			console.log(json);
		}

		document.getElementById("addPost").addEventListener("click", async () => {
			await addPost();
		});

        const stripLeftEachLine = s => {
            if (s == null) return '';
            return String(s).replace(/\r\n/g, '\n').replace(/^[ \t]+/gm, '');
        };
        const hasText = v => v != null && String(v).trim() !== '';

        function createReplyBlock(text) {
            const div = document.createElement('div');
            div.style.whiteSpace = 'pre-wrap';
            const divider = document.createElement('span');
            divider.classList.add('replied');
            div.prepend(divider);
            if (text) div.appendChild(document.createTextNode(text));
            return div;
        }

        function renderSinglePost(post) {
            const li = document.createElement('li');
            li.style.whiteSpace = 'pre-wrap';

            const before = post && post.content_before ? post.content_before : null;
            const after  = post && post.content_after  ? post.content_after  : null;
            const image  = post && post.image && String(post.image).trim() !== '' ? String(post.image) : null;

            const beforeText = before && before.text != null ? stripLeftEachLine(before.text) : '';
            const afterText  = after  && after.text  != null ? stripLeftEachLine(after.text)  : '';

            const beforeExists = !!before;
            const afterExists  = !!after;
            const hasBeforeText = hasText(beforeText);
            const hasAfterText  = hasText(afterText);
            const hasImage = !!image;

            const beforeIsReply = beforeExists && Boolean(before.is_reply);
            const afterIsReply  = afterExists  && Boolean(after.is_reply);

            if (beforeIsReply || afterIsReply) li.classList.add('reply');

            if (beforeExists) {
                if (beforeIsReply) li.appendChild(createReplyBlock(beforeText));
                else if (hasBeforeText) li.appendChild(document.createTextNode(beforeText));
            }

            if (hasImage) {
                const img = document.createElement('img');
                img.src = image;
                li.appendChild(img);
            }

            if (afterExists) {
                if (afterIsReply) {
                    li.appendChild(createReplyBlock(afterText));
                } else if (hasAfterText) {
                    const needNewline = li.childNodes.length > 0;
                    if (needNewline) li.appendChild(document.createTextNode('\n' + afterText));
                    else li.appendChild(document.createTextNode(afterText));
                }
            }

            return li;
        }

        function renderPreview() {
            const ul = document.getElementById('postPreview');
            if (!ul) return;
            ul.innerHTML = '';
            ul.appendChild(renderSinglePost(state));
        }
	</script>
	<script>
		let isAuthenticated = false;

		async function checkAuth() {
			const res = await fetch('/auth/check');
			const data = await res.json().catch(e => { console.error('auth json parse', e); return {}; });
			return Boolean(data.authenticated);
		}

		async function refreshAuth() {
			isAuthenticated = await checkAuth();
			
			if (!isAuthenticated) window.location = "/ohnoey";
		}

		async function init() {
			await refreshAuth();
			

			setInterval(async () => await refreshAuth(), 5000)
		}

		init();
	</script>
</html>